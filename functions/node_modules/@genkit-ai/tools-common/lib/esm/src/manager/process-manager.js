import { spawn } from 'child_process';
import terminate from 'terminate';
import { logger } from '../utils';
export class ProcessManager {
    command;
    args;
    env;
    appProcess;
    originalStdIn;
    _status = 'stopped';
    manualRestart = false;
    constructor(command, args, env = {}) {
        this.command = command;
        this.args = args;
        this.env = env;
    }
    start(options) {
        logger.debug(`Starting process: ${this.command} ${this.args.join(' ')}`);
        return new Promise((resolve, reject) => {
            this._status = 'running';
            this.appProcess = spawn(this.command, this.args, {
                cwd: options?.cwd,
                env: {
                    ...process.env,
                    ...this.env,
                },
                shell: process.platform === 'win32',
            });
            if (!options?.nonInteractive) {
                this.originalStdIn = process.stdin;
                this.appProcess.stderr?.pipe(process.stderr);
                this.appProcess.stdout?.pipe(process.stdout);
                process.stdin?.pipe(this.appProcess.stdin);
            }
            else {
                this.appProcess.stderr?.on('data', (data) => {
                    logger.debug(`[ProcessManager Stderr] ${data.toString()}`);
                });
                this.appProcess.stdout?.on('data', (data) => {
                    logger.debug(`[ProcessManager Stdout] ${data.toString()}`);
                });
            }
            this.appProcess.on('error', (error) => {
                logger.error(`Error in app process: ${error}`);
                this.cleanup();
                reject(error);
            });
            this.appProcess.on('exit', (code, signal) => {
                this.cleanup();
                if (this.manualRestart) {
                    this.manualRestart = false;
                    return;
                }
                if (code === 0 || signal) {
                    resolve();
                }
                else {
                    reject(new Error(`app process exited with code ${code}`));
                }
            });
        });
    }
    async restart(options) {
        this.manualRestart = true;
        await this.kill();
        this.start(options).catch(() => { });
    }
    kill() {
        return new Promise((resolve) => {
            if (!this.appProcess || !this.appProcess.pid || this.appProcess.killed) {
                this._status = 'stopped';
                resolve();
                return;
            }
            this.appProcess.on('exit', () => {
                resolve();
            });
            terminate(this.appProcess.pid, 'SIGTERM', (err) => {
                if (err) {
                    logger.debug(`Error during process termination: ${err.message}`);
                }
                resolve();
            });
        });
    }
    status() {
        return {
            status: this._status,
        };
    }
    cleanup() {
        if (this.originalStdIn) {
            process.stdin.unpipe(this.appProcess?.stdin);
            this.originalStdIn = undefined;
        }
        if (this.appProcess) {
            this.appProcess.stdout?.removeAllListeners();
            this.appProcess.stderr?.removeAllListeners();
        }
        this.appProcess = undefined;
        this._status = 'stopped';
    }
}
//# sourceMappingURL=process-manager.js.map