"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defineRuntimeTools = defineRuntimeTools;
const utils_1 = require("@genkit-ai/tools-common/utils");
const zod_1 = require("zod");
const analytics_js_1 = require("./analytics.js");
const utils_js_1 = require("./utils.js");
function defineRuntimeTools(server, options) {
    server.registerTool('start_runtime', {
        title: 'Starts a Genkit runtime process',
        description: `Use this to start a Genkit runtime process (This is typically the entry point to the users app). Once started, the runtime will be picked up by the \`genkit start\` command to power the Dev UI features like model and flow playgrounds. The inputSchema for this tool matches the function prototype for \`NodeJS.child_process.spawn\`.
        
      Examples: 
        {command: "go", args: ["run", "main.go"]}
        {command: "npm", args: ["run", "dev"]}
        {command: "npm", args: ["run", "dev"], projectRoot: "path/to/project"}`,
        inputSchema: (0, utils_js_1.getCommonSchema)(options.explicitProjectRoot, {
            command: zod_1.z.string().describe('The command to run'),
            args: zod_1.z
                .array(zod_1.z.string())
                .describe('The array of string args for the command to run. Eg: `["run", "dev"]`.'),
        }),
    }, async (opts) => {
        await (0, utils_1.record)(new analytics_js_1.McpRunToolEvent('start_runtime'));
        const rootOrError = (0, utils_js_1.resolveProjectRoot)(options.explicitProjectRoot, opts, options.projectRoot);
        if (typeof rootOrError !== 'string')
            return rootOrError;
        try {
            await options.manager.getManagerWithDevProcess({
                projectRoot: rootOrError,
                command: opts.command,
                args: opts.args,
                explicitProjectRoot: options.explicitProjectRoot,
                timeout: options.timeout,
            });
        }
        catch (err) {
            return {
                content: [
                    {
                        type: 'text',
                        text: 'Error creating runtime manager: ' +
                            (err instanceof Error ? err.stack : JSON.stringify(err)),
                    },
                ],
                isError: true,
            };
        }
        return {
            content: [
                {
                    type: 'text',
                    text: `Done.`,
                },
            ],
        };
    });
    const registerControlTool = (name, title, action) => {
        server.registerTool(name, {
            title,
            description: `Use this to ${action} an existing runtime that was started using the \`start_runtime\` tool`,
            inputSchema: (0, utils_js_1.getCommonSchema)(options.explicitProjectRoot),
        }, async (opts) => {
            await (0, utils_1.record)(new analytics_js_1.McpRunToolEvent(name));
            const rootOrError = (0, utils_js_1.resolveProjectRoot)(options.explicitProjectRoot, opts, options.projectRoot);
            if (typeof rootOrError !== 'string')
                return rootOrError;
            const runtimeManager = await options.manager.getManager(rootOrError);
            if (!runtimeManager.processManager) {
                return {
                    isError: true,
                    content: [
                        { type: 'text', text: `No runtime process currently running.` },
                    ],
                };
            }
            await runtimeManager.processManager[action]();
            return {
                content: [{ type: 'text', text: `Done.` }],
            };
        });
    };
    registerControlTool('kill_runtime', 'Kills any existing Genkit runtime process', 'kill');
    registerControlTool('restart_runtime', 'Restarts any existing Genkit runtime process', 'restart');
}
//# sourceMappingURL=runtime.js.map